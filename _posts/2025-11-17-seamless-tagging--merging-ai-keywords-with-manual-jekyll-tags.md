---
layout: post
title: 'Seamless Tagging: Merging AI Keywords with Manual Jekyll Tags'
date: 2025-11-17 17:58:46
category: tech, jekyll, ai, devops
tags:
- actions
- automated-seo
- automation
- devops
- github
- github-actions
- jekyll-front-matter
- llm
- llm-tag-generation
- python
- python-scripting
---

# Merge Magic: Combining Manual and AI Tags in Your Jekyll Blog

Choosing the best keywords for SEO doesn't have to be a manual chore. The most efficient strategy for Jekyll is to **merge powerful AI keywords** directly into the official **`tags`** list, complementing any tags you've already created.

This guide provides the simple, direct code for integrating an **LLM** (like Gemini) into your **GitHub Actions** pipeline. This solution runs when you open a Pull Request (PR) and automatically updates your post file with the merged tags.

---

## ðŸ’¡ The Core Merge Concept

The goal is simplicity: The system should read your existing tags, ask the LLM for suggestions, and combine the two lists into one unified set in the Front Matter.

1.  **Trigger:** The PR towards `main` fires the workflow.
2.  **Read & Generate:** The Python script reads your current tags (`tags: [manual-tag]`) and calls the LLM for suggestions.
3.  **Merge:** The script combines the two lists, using Python's set structure to **automatically eliminate duplicates**.
4.  **Commit:** GitHub Actions commits the unified list back to your feature branch.

---

## ðŸ’» 1. The Python Brain: `scripts/generate_llm_tags.py`

This script is the minimalist core. It removes all complex safety checks, focusing purely on the merge operation.

***Note:** You must have `pyyaml` and `google-genai` in your `scripts/requirements.txt`.*

```python
import os
import sys
import yaml
from google import genai
# Assume parse_file, write_file, and call_llm_for_tags utilities are defined here.

# --- Configuration ---
POST_TO_PROCESS = os.environ.get('POST_TO_PROCESS')
GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')
TAG_KEY = 'tags' 

if not POST_TO_PROCESS or not GEMINI_API_KEY:
    print("Error: Environment variables must be set.")
    sys.exit(1)

# --- Main Logic ---

def main():
    try:
        front_matter, post_content = parse_file(POST_TO_PROCESS)
        
        print(f"Processing post: {POST_TO_PROCESS}")
        
        # 1. Get existing manual tags (defaults to an empty list if tags field is missing)
        existing_tags = front_matter.get(TAG_KEY, [])
        
        # 2. Call LLM to get new tags
        new_ai_tags = call_llm_for_tags(post_content) 
        
        if not new_ai_tags:
            print("No new tags generated by LLM. Exiting.")
            sys.exit(0)
            
        # 3. Merge Lists: Use a set to automatically handle unique values
        combined_tags_set = set(existing_tags)
        combined_tags_set.update(new_ai_tags)
        
        # Convert back to list for YAML output
        final_tags_list = sorted(list(combined_tags_set))
        
        # 4. Update the official 'tags' field
        front_matter[TAG_KEY] = final_tags_list
        write_file(POST_TO_PROCESS, front_matter, post_content)
        
        print(f"Successfully merged {len(new_ai_tags)} AI tags with existing tags.")

    except Exception as e:
        print(f"A critical error occurred: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

---

## âš™ï¸ 2. The GitHub Actions Workflow: `llm-tag-generator.yml`

This file is the same orchestrator we confirmed, ensuring the merge happens only on the PR branch without touching `main`.

```yaml
name: ðŸ¤– LLM Tag Generator (PR Trigger)

on:
  pull_request:
    branches: ["main"]
    types: [opened, synchronize, reopened]
    paths:
      - '_posts/**.md'

jobs:
  tag_generation:
    runs-on: ubuntu-latest
    permissions:
      contents: write 
    
    steps:
      - name: Checkout PR Branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }} 
          fetch-depth: 0 

      # 1. Identify Modified Files
      - name: Get modified files
        id: files
        uses: tj-actions/changed-files@v46.0.1
        with:
          files: '_posts/**.md'
          
      # ðŸ’¥ NEW HELPER STEP TO FIX PARSING ERROR (No expression syntax here!)
      - name: Set Post File Path Safely
        id: set_path
        run: |
          INPUT_FILES="${{ steps.files.outputs.added_files }}"
          if [[ -z "$INPUT_FILES" ]]; then
            echo "post_path=SKIP" >> $GITHUB_OUTPUT
          else
            read -ra FILE_ARRAY <<< "$INPUT_FILES"           
            POST_PATH="${FILE_ARRAY[0]}"
            echo "post_path=$POST_PATH" >> $GITHUB_OUTPUT
          fi

      # 2. Setup Python and Dependencies
      - name: Setup Python
        if: steps.set_path.outputs.post_path != 'SKIP' # Use the new path check
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install LLM dependencies
        if: steps.set_path.outputs.post_path != 'SKIP'
        run: |
          python -m pip install --upgrade pip
          pip install -r scripts/requirements.txt
          
      # 3. Execute the Tag Generation Script
      - name: Run LLM Tag Generation Script
        if: steps.set_path.outputs.post_path != 'SKIP'
        run: python scripts/generate_llm_tags.py
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          # Now safely use the output from the helper step
          POST_TO_PROCESS: ${{ steps.set_path.outputs.post_path }} 
          
      # 4. Commit generated changes back to the PR
      - name: Commit merged tags to PR branch
        if: success() && steps.set_path.outputs.post_path != 'SKIP'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'feat: [AI] Merged LLM tags into official tags list.'
          file_pattern: '_posts/**.md'
          branch: ${{ github.event.pull_request.head.ref }} 
          commit_user_name: 'AI Tag Generator Bot'
          commit_user_email: 'ai-bot@users.noreply.github.com'
```
