---
layout: post
title: "Seamless Tagging: Merging AI Keywords with Manual Jekyll Tags"
date: 2025-11-17 17:58:46
category: tech, jekyll, ai, devops
tags: [github, actions, llm, automation, python, devops]
---
# Merge Magic: Combining Manual and AI Tags in Your Jekyll Blog

Choosing the best keywords for SEO doesn't have to be a manual chore. The most efficient strategy for Jekyll is to **merge powerful AI keywords** directly into the official **`tags`** list, complementing any tags you've already created.

This guide provides the simple, direct code for integrating an **LLM** (like Gemini) into your **GitHub Actions** pipeline. This solution runs when you open a Pull Request (PR) and automatically updates your post file with the merged tags.

---

## üí° The Core Merge Concept

The goal is simplicity: The system should read your existing tags, ask the LLM for suggestions, and combine the two lists into one unified set in the Front Matter.

1.  **Trigger:** The PR towards `main` fires the workflow.
2.  **Read & Generate:** The Python script reads your current tags (`tags: [manual-tag]`) and calls the LLM for suggestions.
3.  **Merge:** The script combines the two lists, using Python's set structure to **automatically eliminate duplicates**.
4.  **Commit:** GitHub Actions commits the unified list back to your feature branch.

---

## üíª 1. The Python Brain: `scripts/generate_llm_tags.py`

This script is the minimalist core. It removes all complex safety checks, focusing purely on the merge operation.

***Note:** You must have `pyyaml` and `google-genai` in your `scripts/requirements.txt`.*

```python
import os
import sys
import yaml
from google import genai
# Assume parse_file, write_file, and call_llm_for_tags utilities are defined here.

# --- Configuration ---
POST_TO_PROCESS = os.environ.get('POST_TO_PROCESS')
GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')
TAG_KEY = 'tags' 

if not POST_TO_PROCESS or not GEMINI_API_KEY:
    print("Error: Environment variables must be set.")
    sys.exit(1)

# --- Main Logic ---

def main():
    try:
        front_matter, post_content = parse_file(POST_TO_PROCESS)
        
        print(f"Processing post: {POST_TO_PROCESS}")
        
        # 1. Get existing manual tags (defaults to an empty list if tags field is missing)
        existing_tags = front_matter.get(TAG_KEY, [])
        
        # 2. Call LLM to get new tags
        new_ai_tags = call_llm_for_tags(post_content) 
        
        if not new_ai_tags:
            print("No new tags generated by LLM. Exiting.")
            sys.exit(0)
            
        # 3. Merge Lists: Use a set to automatically handle unique values
        combined_tags_set = set(existing_tags)
        combined_tags_set.update(new_ai_tags)
        
        # Convert back to list for YAML output
        final_tags_list = sorted(list(combined_tags_set))
        
        # 4. Update the official 'tags' field
        front_matter[TAG_KEY] = final_tags_list
        write_file(POST_TO_PROCESS, front_matter, post_content)
        
        print(f"Successfully merged {len(new_ai_tags)} AI tags with existing tags.")

    except Exception as e:
        print(f"A critical error occurred: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

---

## ‚öôÔ∏è 2. The GitHub Actions Workflow: `llm-tag-generator.yml`

This file is the same orchestrator we confirmed, ensuring the merge happens only on the PR branch without touching `main`.

```yaml
name: ü§ñ LLM Tag Generator (PR Trigger)

on:
  pull_request:
    # Trigger only when a PR is opened or updated targeting 'main'.
    branches: ["main"]
    types: [opened, synchronize, reopened]
    paths:
      - '_posts/**.md'

jobs:
  tag_generation:
    runs-on: ubuntu-latest
    permissions:
      contents: write 
      
    steps:
      - name: Checkout PR Branch
        uses: actions/checkout@v4
        with:
          # Checks out the branch that initiated the PR
          ref: ${{ github.event.pull_request.head.ref }} 
          fetch-depth: 0 

      # ... (Standard steps: Get modified files, Setup Python, Install Dependencies) ...

      - name: Run LLM Tag Generation Script
        if: steps.files.outputs.modified_files_serialized != '[]'
        run: python scripts/generate_llm_tags.py
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          POST_TO_PROCESS: ${{ fromJson(steps.files.outputs.modified_files_serialized)[0] }} 
          
      # 2. Commit generated changes back to the PR
      - name: Commit merged tags to PR branch
        if: success() && steps.files.outputs.modified_files_serialized != '[]'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'feat: [AI] Merged LLM tags into official tags list.'
          file_pattern: '_posts/**.md'
          branch: ${{ github.event.pull_request.head.ref }} 
          commit_user_name: 'AI Tag Generator Bot'
          commit_user_email: 'ai-bot@users.noreply.github.com'
```


